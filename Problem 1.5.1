# k=same for all, p (unencrypted letter) and encrypted letter change
# create alphabet -> numeric converter (C->2, _->26)
# 0-26 numeral -> five-bit binary converter (2->[0,0,0,1,1])
# add A and B termwise using GF2 (01010+00010=01000) where A and B are lists of 5 bits
from GF2 import one
A=[1,0,1,0,1]
B=[1,1,0,1,0]
[x+y for x in A for y in B]

phrase=input("Type a phrase!")
alphNum={'A':0,'B':1,'C':2,'D':3,'E':4,'F':5,'G':6,'H':7,'I':8,'J':9,'K':10,'L':11,'M':12,'N':13,'O':14,'P':15,'Q':16,'R':17,'S':18,'T':19,'U':20,'V':21,'W':22,'X':23,'Y':24,'Z':25,' ':26}
[ for k in alphNum for v in phrase in alphNum.items()]
digits=set(range(2))

phrase=input("Input a phrase!")

13
+((X-X%2)/2)+X%2
integer=(16*binary[0]+8*binary[1]+4*binary[2]+2*binary[3]+1*binary[4])
1101
[]
alphNumList=[(A,0),(B,1),(C,2),(D,3),(E,4),(F,5),(G,6),(H,7),(I,8),(J,9),(K,10),(L,11),(M,12),(N,13),(N,13),(O,14),(P,15),(Q,16),(R,17),(S,18),(T,19),(U,20),(V,21),(W,22),(X,23),(Y,24),(Z,25),( ,26)]
nums=[]

# function GF2addition that takes two lists of binary values and adds them according to the rules of galois field
# decimalToCharacter converts decimals to characters
# binaryToDecimal
# def Decrypter([0,1,0,0,1],[0,0,1,1,1]):
# [0,1,1,1,0]
# "N"
# Decrypter([1,0,1,0,1],[1,0,0,1,0]) = "G"

cypher=[1,0,1,0,1]
[1,1,1,0,0] key
[0,1,0,0,1] output
X=list(range(0,5,1))
I
output=[ for Z in X]
cypher[0]+key[0]=output[0]
output=[cypher[n]+key[n] for n in X]
outputGF2=[0*X for X in output if X>1]





def Decrypter(cypher,key):
    GF2addition=[1,0,1,0,1],[1,1,1,0,0]



def binary(L):
	integer=(L[0]*16+L[1]*8+L[2]*4+L[3]*2+L[4])
	print(integer)
	alphNum={'A':0,'B':1,'C':2,'D':3,'E':4,'F':5,'G':6,'H':7,'I':8,'J':9,'K':10,'L':11,'M':12,'N':13,'O':14,'P':15,'Q':16,'R':17,'S':18,'T':19,'U':20,'V':21,'W':22,'X':23,'Y':24,'Z':25,' ':26}
	print(alphNum.items)

<<<<<<< Updated upstream
#cyphertext=[0,0,1,1,0]
#key       =[0,1,0,1,0]
def decrypter(X):
    from GF2 import one
    numAlph={0:'A',1:'B',2:'C',3:'D',4:'E',5:'F',6:'G',7:'H',8:'I',9:'J',10:'K',11:'L',12:'M',13:'N',14:'O',15:'P',16:'Q',17:'R',18:'S',19:'T',20:'U',21:'V',22:'W',23:'X',24:'Y',25:'Z',26:' '}
    cyphertext2=[one for x in cyphertext]
    cypher2=[one for x in key]
    L=[(cyphertext2[0]+cypher2[0]),(cyphertext2[1]+cypher2[1]),(cyphertext2[2]+cypher2[2]),(cyphertext2[3]+cypher2[3]),(cyphertext2[4]+cypher2[4])]
    #final binary is [0,1,1,0,0]
    integer=(L[0]*16+L[1]*8+L[2]*4+L[3]*2+L[4])
    print(numAlph[integer])
    #M


def binaryToGF2(X):
    if X==1:
            X=one
            return(X)
    elif X!=0:
                return("Error!")
    else:
        return(X)

L=[binaryToGF2(X) for X ]
=======


from GF2 import one
key=input("Input key as a list of binary numbers!")
text=input("Input text as a list of binary numbers!")
def GF2addition([B]):
    
def binary(L):
	f=(L[0]*16+L[1]*8+L[2]*4+L[3]*2+L[4])
	print(f)
	alphNum={0:'A',1:'B',2:'C',3:'D',4:'E',5:'F',6:'G',7:'H',8:'I',9:'J',10:'K',11:'L',12:'M',13:'N',14:'O',15:'P',16:'Q',17:'R',18:'S',19:'T',20:'U',21:'V',22:'W',23:'X',24:'Y',25:'Z',26:' '}
	return(alphNum[f])
>>>>>>> Stashed changes
