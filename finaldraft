from GF2 import one
class Vec:
    def __init__(self,labels,function):
        self.D = labels
        self.f = function

def lightsOut(gridsize,sparse):
    numpool=list(range(gridsize))
    pointpool=[(X,Y) for X in numpool for Y in numpool]
    initial = Vec(pointpool,{X:one for X in sparse})
    possiblePress = possiblePresses(gridsize)
    final = [buttonPresser(inital, X) for X in possiblePress]
    [X for X in final if final.f == {}]
    return #

#possiblePresses(2) : [[], [(0, 0)], [(0, 1)], [(0, 0), (0, 1)], [(1, 0)], [(0, 0), (1, 0)], [(0, 1), (1, 0)], [(0, 0), (0, 1), (1, 0)], [(1, 1)], [(0, 0), (1, 1)], [(0, 1), (1, 1)], [(0, 0), (0, 1), (1, 1)], [(1, 0), (1, 1)], [(0, 0), (1, 0), (1, 1)], [(0, 1), (1, 0), (1, 1)], [(0, 0), (0, 1), (1, 0), (1, 1)]]
def possiblePresses(gridsize):
    numberOfButtons = gridsize**2
    subs = subsets(numberOfButtons)
    if gridsize == 2:
        return [translator(X) for X in subs]


def translator(list):
    z={1:(0,0),2:(0,1),3:(1,0),4:(1,1)}
    return [z[x] for x in list]


def subsets(i):
    if i == 0:
        return[[]]
    else:
        return induct(subsets(i-1),i)

def induct(listoflists,n):
    return listoflists + [X+[n] for X in listoflists]

# input: a single sequence of presses in a list
# output: final vector showing the domain and the sparse of the final state of the game
def buttonPresser(initial, press):
    buttonToVector(press, initial.D)
    finalvec = addVector(initial,buttonToVector(press))

def getitem(v,d): return v.f[d] if d in v.f else 0

def addVector(a, b):
    x = Vec(a.D,{d:getitem(a,d)+getitem(b,d) for d in a.D})
    # delete 0s in sparse

def buttonToVector(button, domain):
    switchedSet = pressAffect(button, domain)
    return Vec(domain,{X:one for X in switchedSet})

def pressAffect(button, domain):
    x1 = ((button[0]-1), button[1])
    x2 = ((button[0]+1), button[1])
    y1 = (button[0], (button[1]-1))
    y2 = (button[0], (button[1]+1))
    affected = [x1, x2, y1, y2]
    affected2 = []
    for x in affected:
        if x in domain:
            affected2.append(x)
    return affected2
